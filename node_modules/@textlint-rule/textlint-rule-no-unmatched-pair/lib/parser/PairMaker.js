"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PairMaker = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Mark pair character
 * PairMarker aim to mark pair string as a single sentence.
 *
 * For example, Following sentence has two period(。). but it should treat a single sentence
 *
 * > I hear "I'm back to home." from radio.
 *
 * https://ja.wikipedia.org/wiki/%E6%8B%AC%E5%BC%A7
 */

/**
 * @typedef {{key:string,start:string,end:string}[]} PairMark
 */
var PAIR_MARKS = [{
  key: "double quote",
  start: "\"",
  end: "\""
}, {
  key: "angled bracket[]",
  start: "[",
  end: "]"
}, {
  key: "round bracket()",
  start: "(",
  end: ")"
}, {
  key: "curly brace{}",
  start: "{",
  end: "}"
}, {
  key: "かぎ括弧「」",
  start: "\u300C",
  end: "\u300D"
}, {
  key: "丸括弧（）",
  start: "\uFF08",
  end: "\uFF09"
}, {
  key: "二重かぎ括弧『』",
  start: "\u300E",
  end: "\u300F"
}, {
  key: "波括弧｛｝",
  start: "\uFF5B",
  end: "\uFF5D"
}, {
  key: "角括弧［］",
  start: "\uFF3B",
  end: "\uFF3D"
}, {
  key: "重角括弧〚〛",
  start: "\u301A",
  end: "\u301B"
}, {
  key: "隅付き括弧【】",
  start: "\u3010",
  end: "\u3011"
}]; // For readme
// console.log(PAIR_MARKS.map(pair => `- ${pair.key}: \`${pair.start}\` and \`${pair.end}\``).join("\n"));

var PairMaker =
/*#__PURE__*/
function () {
  function PairMaker() {
    _classCallCheck(this, PairMaker);
  }

  _createClass(PairMaker, [{
    key: "mark",
    value: function mark(sourceCode) {
      var string = sourceCode.read();

      if (!string) {
        return;
      } // if current is in a context, should not start other context.
      // PairMaker does not support nest context by design.


      if (sourceCode.isInContext()) {
        // check that string is end mark?
        var pair = PAIR_MARKS.find(function (pair) {
          return pair.end === string;
        });

        if (pair) {
          sourceCode.leaveContext(pair);
        }
      } else {
        var _pair = PAIR_MARKS.find(function (pair) {
          return pair.start === string;
        });

        if (_pair) {
          sourceCode.enterContext(_pair);
        }
      }
    }
  }]);

  return PairMaker;
}();

exports.PairMaker = PairMaker;
//# sourceMappingURL=PairMaker.js.map