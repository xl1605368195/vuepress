// LICENSE : MIT
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var test_util_1 = require("./test-util");
var textlint_1 = require("textlint");
var coreFlags = require("@textlint/feature-flag").coreFlags;
/* eslint-disable no-invalid-this */
var globalObject = global;
var describe = typeof globalObject.describe === "function"
    ? globalObject.describe
    : function (_text, method) {
        return method.apply(this);
    };
var it = typeof globalObject.it === "function"
    ? globalObject.it
    : function (_text, method) {
        return method.apply(this);
    };
/* eslint-enable no-invalid-this */
/**
 * get fixer function from ruleCreator
 * if not found, throw error
 * @param {Function|Object} ruleCreator
 * @param {string} ruleName
 */
function assertHasFixer(ruleCreator, ruleName) {
    if (typeof ruleCreator.fixer === "function") {
        return;
    }
    if (typeof ruleCreator === "function") {
        return;
    }
    throw new Error("Not found `fixer` function in the ruleCreator: " + ruleName);
}
function assertTestConfig(testConfig) {
    assert.notEqual(testConfig, null, "TestConfig is null");
    assert.notEqual(Object.keys(testConfig).length === 0 && testConfig.constructor === Object, true, "TestConfig is empty");
    assert(Array.isArray(testConfig.rules), "TestConfig.rules should be an array");
    assert(testConfig.rules.length > 0, "TestConfig.rules should have at least one rule");
    testConfig.rules.forEach(function (rule) {
        assert(rule.hasOwnProperty("ruleId"), "ruleId property not found");
        assert(rule.hasOwnProperty("rule"), "rule property not found");
    });
    if (typeof testConfig.plugins !== "undefined") {
        assert(Array.isArray(testConfig.plugins), "TestConfig.plugins should be an array");
        testConfig.plugins.forEach(function (plugin) {
            assert(plugin.hasOwnProperty("pluginId"), "pluginId property not found");
            assert(plugin.hasOwnProperty("plugin"), "plugin property not found");
        });
    }
}
function isTestConfig(arg) {
    if (arg.hasOwnProperty("rules")) {
        return true;
    }
    if (typeof arg.fixer === "function" || typeof arg === "function") {
        return false;
    }
    return true;
}
function createTestRuleSet(testConfigRules) {
    var testRuleSet = {
        rules: {},
        rulesOptions: {}
    };
    testConfigRules.forEach(function (rule) {
        var ruleName = rule.ruleId;
        var ruleOptions = rule.options;
        testRuleSet.rules[ruleName] = rule.rule;
        testRuleSet.rulesOptions[ruleName] = ruleOptions;
    });
    return testRuleSet;
}
function createTestPluginSet(testConfigPlugins) {
    var testPluginSet = {
        plugins: {},
        pluginOptions: {}
    };
    testConfigPlugins.forEach(function (plugin) {
        var pluginName = plugin.pluginId;
        var pluginOptions = plugin.options;
        testPluginSet.plugins[pluginName] = plugin.plugin;
        testPluginSet.pluginOptions[pluginName] = pluginOptions;
    });
    return testPluginSet;
}
var TextLintTester = /** @class */ (function () {
    function TextLintTester() {
        if (typeof coreFlags === "object") {
            coreFlags.runningTester = true;
        }
    }
    TextLintTester.prototype.testValidPattern = function (name, param, valid) {
        var text = typeof valid === "object" ? valid.text : valid;
        var inputPath = typeof valid === "object" ? valid.inputPath : undefined;
        var ext = typeof valid === "object" && valid.ext !== undefined ? valid.ext : ".md";
        var textlint = new textlint_1.TextLintCore();
        if (isTestConfig(param)) {
            var testRuleSet = createTestRuleSet(param.rules);
            textlint.setupRules(testRuleSet.rules, testRuleSet.rulesOptions);
            if (param.plugins !== undefined) {
                var testPluginSet = createTestPluginSet(param.plugins);
                textlint.setupPlugins(testPluginSet.plugins, testPluginSet.pluginOptions);
            }
        }
        else {
            var options = typeof valid === "object"
                ? valid.options
                : // just enable
                    true;
            textlint.setupRules((_a = {},
                _a[name] = param,
                _a), (_b = {},
                _b[name] = options,
                _b));
        }
        it(inputPath || text, function () {
            return test_util_1.testValid({ textlint: textlint, inputPath: inputPath, text: text, ext: ext });
        });
        var _a, _b;
    };
    TextLintTester.prototype.testInvalidPattern = function (name, param, invalid) {
        var errors = invalid.errors;
        var inputPath = invalid.inputPath;
        var text = invalid.text;
        var ext = invalid.ext !== undefined ? invalid.ext : ".md";
        var textlint = new textlint_1.TextLintCore();
        if (isTestConfig(param)) {
            var testRuleSet = createTestRuleSet(param.rules);
            textlint.setupRules(testRuleSet.rules, testRuleSet.rulesOptions);
            if (Array.isArray(param.plugins)) {
                var testPluginSet = createTestPluginSet(param.plugins);
                textlint.setupPlugins(testPluginSet.plugins, testPluginSet.pluginOptions);
            }
        }
        else {
            var options = invalid.options;
            textlint.setupRules((_a = {},
                _a[name] = param,
                _a), (_b = {},
                _b[name] = options,
                _b));
        }
        it(inputPath || text, function () {
            return test_util_1.testInvalid({ textlint: textlint, inputPath: inputPath, text: text, ext: ext, errors: errors });
        });
        // --fix
        if (invalid.hasOwnProperty("output")) {
            it("Fixer: " + (inputPath || text), function () {
                if (isTestConfig(param)) {
                    param.rules.forEach(function (rule) {
                        assertHasFixer(rule.rule, rule.ruleId);
                    });
                }
                else {
                    assertHasFixer(param, name);
                }
                var promise;
                if (inputPath !== undefined) {
                    promise = textlint.fixFile(inputPath);
                }
                else if (text !== undefined) {
                    promise = textlint.fixText(text, ext);
                }
                else {
                    throw new Error("Should set `text` or `inputPath`");
                }
                return promise.then(function (result) {
                    var output = invalid.output;
                    assert.strictEqual(result.output, output);
                });
            });
        }
        var _a, _b;
    };
    /**
     * run test for textlint rule.
     * @param {string} name name is name of the test or rule
     * @param {TextlintRuleModule|TestConfig} param param is TextlintRuleCreator or TestConfig
     * @param {string[]|object[]} [valid]
     * @param {object[]} [invalid]
     */
    TextLintTester.prototype.run = function (name, param, _a) {
        var _this = this;
        var _b = _a.valid, valid = _b === void 0 ? [] : _b, _c = _a.invalid, invalid = _c === void 0 ? [] : _c;
        if (isTestConfig(param)) {
            assertTestConfig(param);
            if (valid) {
                valid.forEach(function (validCase) {
                    assert(!validCase.hasOwnProperty("options"), "Could not specify options property in valid object when TestConfig was passed. Use TestConfig.rules.options.");
                });
            }
            if (invalid) {
                invalid.forEach(function (invalidCase) {
                    assert(!invalidCase.hasOwnProperty("options"), "Could not specify options property in invalid object when TestConfig was passed. Use TestConfig.rules.options.");
                });
            }
        }
        describe(name, function () {
            invalid.forEach(function (state) {
                _this.testInvalidPattern(name, param, state);
            });
            valid.forEach(function (state) {
                _this.testValidPattern(name, param, state);
            });
        });
    };
    return TextLintTester;
}());
exports.TextLintTester = TextLintTester;
//# sourceMappingURL=textlint-tester.js.map