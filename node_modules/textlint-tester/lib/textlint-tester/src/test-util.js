// LICENSE : MIT
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var fs = require("fs");
/**
 *
 * @param {string} [text]
 * @param {string} [inputPath]
 * @returns {string}
 */
function getTestText(_a) {
    var text = _a.text, inputPath = _a.inputPath;
    if (typeof inputPath === "string") {
        return fs.readFileSync(inputPath, "utf-8");
    }
    if (typeof text === "string") {
        return text;
    }
    throw new Error("should be defined { text } or { inputPath }");
}
/**
 * @param {TextLintCore} textlint
 * @param {string} [text]
 * @param {string} [ext]
 * @param {string} [inputPath]
 * @param {*[]} errors
 */
function testInvalid(_a) {
    var textlint = _a.textlint, inputPath = _a.inputPath, text = _a.text, ext = _a.ext, errors = _a.errors;
    var actualText = getTestText({ text: text, inputPath: inputPath });
    var lines = actualText.split(/\n/);
    assert.strictEqual(typeof actualText, "string", "invalid property should have text string\ne.g.)\ninvalid : [\n    {\n        text: \"example text\",\n        errors: [{\n            message: \"expected message\"\n        }]\n    }\n]\n");
    assert.ok(Array.isArray(errors), "invalid property should have array of expected error\ne.g.)\ninvalid : [\n    {\n        text: \"example text\",\n        errors: [{\n            message: \"expected message\"\n        }]\n    }\n]\n            ");
    var errorLength = errors.length;
    var promise;
    if (inputPath !== undefined) {
        promise = textlint.lintFile(inputPath);
    }
    else if (text !== undefined) {
        promise = textlint.lintText(text, ext);
    }
    else {
        throw new Error("Should set `text` or `inputPath`");
    }
    return promise.then(function (lintResult) {
        assert.strictEqual(lintResult.messages.length, errorLength, "invalid: should have " + errorLength + " errors but had " + lintResult.messages.length + ":\n===Text===:\n" + actualText + "\n\n==Result==:\n" + JSON.stringify(lintResult, null, 4));
        errors.forEach(function (error, errorIndex) {
            var ruleId = error.ruleId, message = error.message, line = error.line, column = error.column, index = error.index;
            var resultMessageObject = lintResult.messages[errorIndex];
            // check
            assert.ok(resultMessageObject.line >= 1, "lint result's line number is " + resultMessageObject.line + ", should be over than 1.");
            assert.ok(resultMessageObject.line <= lines.length, "lint result's line number is line:" + resultMessageObject.line + ", but total line number of the text is " + lines.length + ".\nThe result's line number should be less than " + lines.length);
            var columnText = lines[resultMessageObject.line - 1];
            assert.ok(resultMessageObject.column >= 1, "lint result's column number is " + resultMessageObject.column + ", should be over than 1.");
            assert.ok(resultMessageObject.column <= columnText.length + 1, "lint result's column number is " + resultMessageObject.column + "," +
                ("but the length of the text @ line:" + resultMessageObject.line + " is " + (columnText.length + 1) + ".\nThe result's column number should be less than " + (columnText.length + 1)));
            if (ruleId !== undefined) {
                var resultRuleId = resultMessageObject.ruleId;
                assert.strictEqual(resultRuleId, ruleId, "\"ruleId should be \"" + ruleId + "\"");
            }
            if (message !== undefined) {
                var resultMessage = resultMessageObject.message;
                assert.strictEqual(resultMessage, message, "\"message should be \"" + message + "\"");
            }
            if (line !== undefined) {
                var resultLine = resultMessageObject.line;
                assert.strictEqual(resultLine, line, "line should be " + line);
            }
            if (column !== undefined) {
                var resultColumn = resultMessageObject.column;
                assert.strictEqual(resultColumn, column, "\"column should be " + column);
            }
            if (index !== undefined) {
                var resultIndex = resultMessageObject.index;
                assert.strictEqual(resultIndex, index, "\"index should be " + index);
            }
        });
    });
}
exports.testInvalid = testInvalid;
/**
 * @param {TextLintCore} textlint
 * @param {string} [inputPath]
 * @param {string} [text]
 * @param {string} [ext]
 */
function testValid(_a) {
    var textlint = _a.textlint, inputPath = _a.inputPath, text = _a.text, ext = _a.ext;
    var actualText = getTestText({ text: text, inputPath: inputPath });
    assert.strictEqual(typeof actualText, "string", "valid should has string of text.");
    var promise;
    if (inputPath !== undefined) {
        promise = textlint.lintFile(inputPath);
    }
    else if (text !== undefined) {
        promise = textlint.lintText(text, ext);
    }
    else {
        throw new Error("Should set `text` or `inputPath`");
    }
    return promise.then(function (results) {
        assert.strictEqual(results.messages.length, 0, "valid: should have no errors but had Error results:\n===Text===:\n" + actualText + "\n\n==Result==:\n" + JSON.stringify(results, null, 4));
    });
}
exports.testValid = testValid;
//# sourceMappingURL=test-util.js.map